{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p>El objetivo de esta tarea es resolver la siguiente integral:</p> \\[ I = \\int_1^3 \\left( x^6 - x^2 \\sin(2x) \\right)\\, dx \\] <p>Para esto, utilizamos el m\u00e9todo de la cuadratura Gaussiana, usando los polinomios de Legendre, m\u00e9todo tambi\u00e9n conocido como cuadratura Gauss-Legendre.</p> <p>Se implement\u00f3 el m\u00e9todo mediante un script de Python <code>cuadrature.py</code>. Se probaron varios valores de \\(N\\) con el fin de encontrar un valor para la integral con un error relativo menor a \\(10^{-10}\\), respecto al valor anal\u00edtico.</p> <p>Adem\u00e1s, se realiza la documentaci\u00f3n del c\u00f3digo usando MkDocs.</p>"},{"location":"explanation/","title":"Explicaci\u00f3n del M\u00e9todo de Cuadratura Gaussiana","text":"<p>La cuadratura Gauss-Legendre es un m\u00e9todo que permite aproximar integrales en el intervalo \\([-1,1]\\):</p> \\[ \\int_{-1}^1 f(t)\\,dt \\approx \\sum_{i=1}^N w_i f(t_i) \\] <p>donde \\(t_i\\) son las ra\u00edces del polinomio de Legendre de orden \\(N\\), y \\(w_i\\) son los pesos asociados.</p> <p>Este m\u00e9todo permite obtener un mejor resultado que el m\u00e9todo del trapecio para un mismo \\(N\\).</p> <p>Se utilizan los polinomios de Legendre, los cuales son funciones matem\u00e1ticas que se usan como \"base\" para nuestro m\u00e9todo. Los primeros son:</p> <ul> <li>\\(P_0(x) = 1\\)</li> <li>\\(P_1(x) = x\\)</li> <li>\\(P_2(x) = \\tfrac{1}{2}(3x^2 - 1)\\)</li> <li>\\(P_3(x) = \\tfrac{1}{2}(5x^3 - 3x)\\)</li> </ul> <p>Para integrar en un intervalo \\([a,b]\\), se usa el cambio de variable:</p> \\[ x = \\tfrac{b-a}{2}\\, t + \\tfrac{b+a}{2} \\] <p>Esto nos da:</p> \\[ \\int_a^b f(x)\\,dx \\;\\approx\\; \\tfrac{b-a}{2} \\sum_{i=1}^N w_i \\, f\\!\\left(\\tfrac{b-a}{2}\\,t_i + \\tfrac{b+a}{2}\\right). \\] <p>Para nuestro caso espec\u00edfico \\([1,3]\\):</p> \\[ x = \\frac{3-1}{2}\\,\\xi + \\frac{1+3}{2} \\;=\\; \\xi + 2 \\]"},{"location":"explanation/#algoritmo-para-la-aproximacion","title":"Algoritmo para la aproximaci\u00f3n","text":"<ol> <li>Empezar con \\(N = 1\\) punto.  </li> <li>Calcular puntos y pesos en \\([-1, 1]\\) usando Legendre.  </li> <li>Escalar al intervalo \\([1, 3]\\).  </li> <li>Evaluar la integral usando la suma ponderada.  </li> <li>Calcular el error comparando con el valor exacto.  </li> <li>Si el error es muy grande, aumentar \\(N\\) y repetir.  </li> </ol> <p>Este m\u00e9todo es exacto para polinomios hasta grado \\(2N - 1\\).</p>"},{"location":"reference/","title":"Referencia de API","text":"<p>Esta secci\u00f3n contiene la documentaci\u00f3n autom\u00e1tica de todas las funciones del m\u00f3dulo <code>cuadrature.py</code>.</p> <p>M\u00f3dulo de cuadratura Gaussiana para integraci\u00f3n num\u00e9rica, usando los polinomios de Legendre.</p> <p>Este m\u00f3dulo implementa el m\u00e9todo de cuadratura Gauss-Legendre para resolver la integral: I = \u222b\u2081\u00b3 [x\u2076 - x\u00b2 sin(2x)] dx</p> <p>Para esto, se implemento el m\u00e9todo mediante un script de python <code>cuadrature.py</code>, se probo varios valores de \\(N\\) con el fin de encontrar un valor para la integral con un error relativo menor a 1e-10, respecto al valor analitico.</p>"},{"location":"reference/#cuadrature.derivada_analitica","title":"<code>derivada_analitica(x)</code>","text":"<p>Calcula la antiderivada de f(x) = x\u2076 - x\u00b2 sin(2x).</p> <p>La antiderivada (se calculo manualmente) es: F(x) = x\u2077/7 + x\u00b2/2 cos(2x) - x/2 sin(2x) - 1/4 cos(2x)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or ndarray</code> <p>Variable independiente, preimagen.</p> required <p>Returns:</p> Type Description <p>float or numpy.ndarray: Valor de la antiderivada evaluada en x.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # F(0) = -1/4\n&gt;&gt;&gt; abs(derivada_analitica(0) - (-0.25)) &lt; 1e-10\nTrue\n&gt;&gt;&gt; # Verificar que F'(x) = f(x) aproximadamente, usando la definici\u00f3n de derivada y el calculo de un error con tolerancia de 1e-10\n&gt;&gt;&gt; x = 1.0\n&gt;&gt;&gt; h = 1e-10\n&gt;&gt;&gt; derivada_num = (derivada_analitica(x + h) - derivada_analitica(x)) / h\n&gt;&gt;&gt; derivada_exacta = func_arg_int(x)\n&gt;&gt;&gt; abs(derivada_num - derivada_exacta) &lt; 1e-10\nTrue\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def derivada_analitica(x):\n    \"\"\"\n    Calcula la antiderivada de f(x) = x\u2076 - x\u00b2 sin(2x).\n\n    La antiderivada (se calculo manualmente) es: F(x) = x\u2077/7 + x\u00b2/2 cos(2x) - x/2 sin(2x) - 1/4 cos(2x)\n\n    Args:\n        x (float or numpy.ndarray): Variable independiente, preimagen.\n\n    Returns:\n        float or numpy.ndarray: Valor de la antiderivada evaluada en x.\n\n    Examples:\n        &gt;&gt;&gt; # F(0) = -1/4\n        &gt;&gt;&gt; abs(derivada_analitica(0) - (-0.25)) &lt; 1e-10\n        True\n        &gt;&gt;&gt; # Verificar que F'(x) = f(x) aproximadamente, usando la definici\u00f3n de derivada y el calculo de un error con tolerancia de 1e-10\n        &gt;&gt;&gt; x = 1.0\n        &gt;&gt;&gt; h = 1e-10\n        &gt;&gt;&gt; derivada_num = (derivada_analitica(x + h) - derivada_analitica(x)) / h\n        &gt;&gt;&gt; derivada_exacta = func_arg_int(x)\n        &gt;&gt;&gt; abs(derivada_num - derivada_exacta) &lt; 1e-10\n        True\n    \"\"\"\n    return (x**7 / 7 + x**2 / 2 * np.cos(2*x) - \n            x / 2 * np.sin(2*x) - 1/4 * np.cos(2*x))\n</code></pre>"},{"location":"reference/#cuadrature.eva_int","title":"<code>eva_int(pto, peso, func)</code>","text":"<p>Eval\u00faa la integral aproximada usando cuadratura Gauss-Legendre.</p> <p>Calcula la integral usando la suma de la funci\u00f3n evaluada en los puntos de colocaci\u00f3n por los pesos respectivos.</p> <p>Parameters:</p> Name Type Description Default <code>pto</code> <code>ndarray</code> <p>Puntos de colocaci\u00f3n.</p> required <code>peso</code> <code>ndarray</code> <p>Pesos respectivos.</p> required <code>func</code> <code>callable</code> <p>Funci\u00f3n a integrar.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Valor aproximado de la integral.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pto, peso = gaussxw(2)\n&gt;&gt;&gt; pto_esc, peso_esc = gaussxwab(0, 1, pto, peso)\n&gt;&gt;&gt; # Integrar funci\u00f3n constante f(x) = 2\n&gt;&gt;&gt; result = eva_int(pto_esc, peso_esc, lambda x: 2)\n&gt;&gt;&gt; result\n2.0\n&gt;&gt;&gt; # El resultado es de la integral de 2 de 0 a 1 es 2\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def eva_int(pto, peso, func):\n    \"\"\"\n    Eval\u00faa la integral aproximada usando cuadratura Gauss-Legendre.\n\n    Calcula la integral usando la suma de la funci\u00f3n evaluada en los puntos de colocaci\u00f3n por los pesos respectivos.\n\n    Args:\n        pto (numpy.ndarray): Puntos de colocaci\u00f3n.\n        peso (numpy.ndarray): Pesos respectivos.\n        func (callable): Funci\u00f3n a integrar.\n\n    Returns:\n        float: Valor aproximado de la integral.\n\n    Examples:\n        &gt;&gt;&gt; pto, peso = gaussxw(2)\n        &gt;&gt;&gt; pto_esc, peso_esc = gaussxwab(0, 1, pto, peso)\n        &gt;&gt;&gt; # Integrar funci\u00f3n constante f(x) = 2\n        &gt;&gt;&gt; result = eva_int(pto_esc, peso_esc, lambda x: 2)\n        &gt;&gt;&gt; result\n        2.0\n        &gt;&gt;&gt; # El resultado es de la integral de 2 de 0 a 1 es 2\n    \"\"\"\n    return np.sum(peso * func(pto))\n</code></pre>"},{"location":"reference/#cuadrature.func_arg_int","title":"<code>func_arg_int(x)</code>","text":"<p>Funci\u00f3n que queremos integrar: f(x) = x\u2076 - x\u00b2 sin(2x).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or ndarray</code> <p>Variable independiente, preimagen.</p> required <p>Returns:</p> Type Description <p>float or numpy.ndarray: Valor de la funci\u00f3n evaluada en x.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; #Ejemplo con punto\n&gt;&gt;&gt; func_arg_int(0)\n0.0\n&gt;&gt;&gt; func_arg_int(1) &gt; 0\nTrue\n&gt;&gt;&gt; # Ejemplo con array\n&gt;&gt;&gt; x_vals = np.array([0, 1])\n&gt;&gt;&gt; results = func_arg_int(x_vals)\n&gt;&gt;&gt; len(results) == 2\nTrue\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def func_arg_int(x):\n    \"\"\"\n    Funci\u00f3n que queremos integrar: f(x) = x\u2076 - x\u00b2 sin(2x).\n\n    Args:\n        x (float or numpy.ndarray): Variable independiente, preimagen.\n\n    Returns:\n        float or numpy.ndarray: Valor de la funci\u00f3n evaluada en x.\n\n    Examples:\n        &gt;&gt;&gt; #Ejemplo con punto\n        &gt;&gt;&gt; func_arg_int(0)\n        0.0\n        &gt;&gt;&gt; func_arg_int(1) &gt; 0\n        True\n        &gt;&gt;&gt; # Ejemplo con array\n        &gt;&gt;&gt; x_vals = np.array([0, 1])\n        &gt;&gt;&gt; results = func_arg_int(x_vals)\n        &gt;&gt;&gt; len(results) == 2\n        True\n    \"\"\"\n    return x**6 - x**2 * np.sin(2 * x)\n</code></pre>"},{"location":"reference/#cuadrature.gaussxw","title":"<code>gaussxw(N)</code>","text":"<p>Calcula los nodos y pesos de la cuadratura Gauss-Legendre en el intervalo [-1, 1].</p> <p>Utiliza los polinomios de Legendre para generar los puntos de colocaci\u00f3n y sus respectivos pesos que se utilizaran para la cuadratura Gaussiana.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>N\u00famero de puntos de la cuadratura, cambiar este valor cambia el resultado de la aproximaci\u00f3n de la integral.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>Una tupla (pto, peso) donde: - pto (numpy.ndarray): Array con los puntos de colocaci\u00f3n/nodos - peso (numpy.ndarray): Array con los pesos correspondientes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pto, peso = gaussxw(1)  # Un solo punto\n&gt;&gt;&gt; pto[0]  # El punto est\u00e1 en el centro\n0.0\n&gt;&gt;&gt; peso[0]  # El peso es 2 (longitud del intervalo [-1,1])\n2.0\n&gt;&gt;&gt; pto, peso = gaussxw(2) # Con 2 puntos\n&gt;&gt;&gt; len(pto)\n2\n&gt;&gt;&gt; len(peso)\n2\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def gaussxw(N):\n    \"\"\"\n    Calcula los nodos y pesos de la cuadratura Gauss-Legendre en el intervalo [-1, 1].\n\n    Utiliza los polinomios de Legendre para generar los puntos de colocaci\u00f3n\n    y sus respectivos pesos que se utilizaran para la cuadratura Gaussiana.\n\n    Args:\n        N (int): N\u00famero de puntos de la cuadratura, cambiar este valor cambia el resultado de la aproximaci\u00f3n de la integral.\n\n    Returns:\n        tuple: Una tupla (pto, peso) donde:\n            - pto (numpy.ndarray): Array con los puntos de colocaci\u00f3n/nodos\n            - peso (numpy.ndarray): Array con los pesos correspondientes\n\n    Examples:\n        &gt;&gt;&gt; pto, peso = gaussxw(1)  # Un solo punto\n        &gt;&gt;&gt; pto[0]  # El punto est\u00e1 en el centro\n        0.0\n        &gt;&gt;&gt; peso[0]  # El peso es 2 (longitud del intervalo [-1,1])\n        2.0\n        &gt;&gt;&gt; pto, peso = gaussxw(2) # Con 2 puntos\n        &gt;&gt;&gt; len(pto)\n        2\n        &gt;&gt;&gt; len(peso)\n        2\n    \"\"\"\n    pto, peso = np.polynomial.legendre.leggauss(N)\n    return pto, peso\n</code></pre>"},{"location":"reference/#cuadrature.gaussxwab","title":"<code>gaussxwab(liminf, limsup, pto, peso)</code>","text":"<p>Escala los nodos y pesos desde el intervalo [-1, 1] a [liminf, limsup].</p> <p>Transforma los puntos de colocaci\u00f3n y pesos de la cuadratura Gaussiana del intervalo est\u00e1ndar [-1, 1] a nuevos puntos de colocaci\u00f3n y pesos para cualquier intervalo [a, b].</p> <p>Parameters:</p> Name Type Description Default <code>liminf</code> <code>float</code> <p>L\u00edmite inferior del intervalo de integraci\u00f3n.</p> required <code>limsup</code> <code>float</code> <p>L\u00edmite superior del intervalo de integraci\u00f3n.</p> required <code>pto</code> <code>ndarray</code> <p>Puntos de colocaci\u00f3n en [-1, 1].</p> required <code>peso</code> <code>ndarray</code> <p>Pesos correspondientes en [-1, 1].</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>Una tupla (pto_escalados, peso_escalados) donde: - pto_esc (numpy.ndarray): Puntos transformados al nuevo intervalo - peso_esc (numpy.ndarray): Pesos transformados al nuevo intervalo</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pto, peso = gaussxw(2)\n&gt;&gt;&gt; pto_esc, peso_esc = gaussxwab(0, 1, pto, peso)\n&gt;&gt;&gt; len(pto_esc)\n2\n&gt;&gt;&gt; # Los puntos est\u00e1n ahora en [1, 3] en lugar de [-1, 1]\n&gt;&gt;&gt; min(pto_esc) &gt;= 1\nTrue\n&gt;&gt;&gt; max(pto_esc) &lt;= 3\nTrue\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def gaussxwab(liminf, limsup, pto, peso):\n    \"\"\"\n    Escala los nodos y pesos desde el intervalo [-1, 1] a [liminf, limsup].\n\n    Transforma los puntos de colocaci\u00f3n y pesos de la cuadratura Gaussiana\n    del intervalo est\u00e1ndar [-1, 1] a nuevos puntos de colocaci\u00f3n y pesos para cualquier intervalo [a, b].\n\n    Args:\n        liminf (float): L\u00edmite inferior del intervalo de integraci\u00f3n.\n        limsup (float): L\u00edmite superior del intervalo de integraci\u00f3n.\n        pto (numpy.ndarray): Puntos de colocaci\u00f3n en [-1, 1].\n        peso (numpy.ndarray): Pesos correspondientes en [-1, 1].\n\n    Returns:\n        tuple: Una tupla (pto_escalados, peso_escalados) donde:\n            - pto_esc (numpy.ndarray): Puntos transformados al nuevo intervalo\n            - peso_esc (numpy.ndarray): Pesos transformados al nuevo intervalo\n\n    Examples:\n        &gt;&gt;&gt; pto, peso = gaussxw(2)\n        &gt;&gt;&gt; pto_esc, peso_esc = gaussxwab(0, 1, pto, peso)\n        &gt;&gt;&gt; len(pto_esc)\n        2\n        &gt;&gt;&gt; # Los puntos est\u00e1n ahora en [1, 3] en lugar de [-1, 1]\n        &gt;&gt;&gt; min(pto_esc) &gt;= 1\n        True\n        &gt;&gt;&gt; max(pto_esc) &lt;= 3\n        True\n    \"\"\"\n    return (0.5 * (limsup - liminf) * pto + 0.5 * (limsup + liminf), \n            0.5 * (limsup - liminf) * peso)\n</code></pre>"},{"location":"tutorials/","title":"Tutorial - Ejemplo de Uso","text":""},{"location":"tutorials/#ejecutar-el-script-desde-el-terminal","title":"Ejecutar el script desde el terminal","text":"<pre><code>python cuadrature.py\n</code></pre> <p>Esto resuelve autom\u00e1ticamente la integral y genera los gr\u00e1ficos.</p>"},{"location":"tutorials/#graficos-generados","title":"Gr\u00e1ficos generados","text":"<p>Al ejecutar el script, se generan dos gr\u00e1ficos:</p> <p></p> <p></p>"},{"location":"tutorials/#usar-las-funciones","title":"Usar las funciones","text":"<pre><code>import cuadrature as cq\n\n# Calcular integral con 5 puntos\npto, peso = cq.gaussxw(5)\npto_esc, peso_esc = cq.gaussxwab(1, 3, pto, peso)\nresultado = cq.eva_int(pto_esc, peso_esc, cq.func_arg_int)\n\nprint(f\"Integral: {resultado}\")\n\n# Comparar con valor exacto\nexacto = cq.derivada_analitica(3) - cq.derivada_analitica(1)\nerror = abs(resultado - exacto) / exacto\n\nprint(f\"Valor exacto: {exacto}\")\nprint(f\"Error: {error:.2e}\")\n</code></pre>"},{"location":"tutorials/#resultado-esperado","title":"Resultado esperado","text":"<pre><code>Integral: 317.34422672196945\nValor exacto: 317.34424667382643\nError: 6.29e-08\n</code></pre>"}]}