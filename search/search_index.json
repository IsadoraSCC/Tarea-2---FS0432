{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p>El objetivo de esta tarea es resolver la siguiente integral:</p> \\[ I = \\int_1^3 \\left( x^6 - x^2 \\sin(2x) \\right)\\, dx \\] <p>Para esto, utilizamos el m\u00e9todo de la cuadratura Gaussiana, usando los polinomios de Legendre, m\u00e9todo tambi\u00e9n conocido como cuadratura Gauss-Legendre.</p> <p>Se implement\u00f3 el m\u00e9todo mediante un script de Python <code>cuadrature.py</code>. Se probaron varios valores de \\(N\\) con el fin de encontrar un valor para la integral con un error relativo menor a \\(10^{-10}\\), respecto al valor anal\u00edtico.</p> <p>Adem\u00e1s, se realiza la documentaci\u00f3n del c\u00f3digo usando MkDocs.</p>"},{"location":"explanation/","title":"Explicaci\u00f3n del M\u00e9todo de Cuadratura Gaussiana","text":"<p>La cuadratura Gauss-Legendre es un m\u00e9todo que permite aproximar integrales en el intervalo \\([-1,1]\\):</p> \\[ \\int_{-1}^1 f(t)\\,dt \\approx \\sum_{i=1}^N w_i f(t_i) \\] <p>donde \\(t_i\\) son las ra\u00edces del polinomio de Legendre de orden \\(N\\), y \\(w_i\\) son los pesos asociados.</p> <p>Este m\u00e9todo permite obtener un mejor resultado que el m\u00e9todo del trapecio para un mismo \\(N\\).</p> <p>Se utilizan los polinomios de Legendre, los cuales son funciones matem\u00e1ticas que se usan como \"base\" para nuestro m\u00e9todo. Los primeros son:</p> <ul> <li>\\(P_0(x) = 1\\)</li> <li>\\(P_1(x) = x\\)</li> <li>\\(P_2(x) = \\tfrac{1}{2}(3x^2 - 1)\\)</li> <li>\\(P_3(x) = \\tfrac{1}{2}(5x^3 - 3x)\\)</li> </ul> <p>Para integrar en un intervalo \\([a,b]\\), se usa el cambio de variable:</p> \\[ x = \\tfrac{b-a}{2}\\, t + \\tfrac{b+a}{2} \\] <p>Esto nos da:</p> \\[ \\int_a^b f(x)\\,dx \\;\\approx\\; \\tfrac{b-a}{2} \\sum_{i=1}^N w_i \\, f\\!\\left(\\tfrac{b-a}{2}\\,t_i + \\tfrac{b+a}{2}\\right). \\] <p>Para nuestro caso espec\u00edfico \\([1,3]\\):</p> \\[ x = \\frac{3-1}{2}\\,\\xi + \\frac{1+3}{2} \\;=\\; \\xi + 2 \\]"},{"location":"explanation/#algoritmo-para-la-aproximacion","title":"Algoritmo para la aproximaci\u00f3n","text":"<ol> <li>Empezar con \\(N = 1\\) punto.  </li> <li>Calcular puntos y pesos en \\([-1, 1]\\) usando Legendre.  </li> <li>Escalar al intervalo \\([1, 3]\\).  </li> <li>Evaluar la integral usando la suma ponderada.  </li> <li>Calcular el error comparando con el valor exacto.  </li> <li>Si el error es muy grande, aumentar \\(N\\) y repetir.  </li> </ol> <p>Este m\u00e9todo es exacto para polinomios hasta grado \\(2N - 1\\).</p>"},{"location":"reference/","title":"Referencia de API","text":"<p>Esta secci\u00f3n contiene la documentaci\u00f3n autom\u00e1tica de todas las funciones del m\u00f3dulo <code>cuadrature.py</code>.</p> <p>M\u00f3dulo de cuadratura Gaussiana para integraci\u00f3n num\u00e9rica, usando los polinomios de Legendre.</p> <p>Este m\u00f3dulo implementa el m\u00e9todo de cuadratura Gauss-Legendre para resolver la integral: I = \u222b\u2081\u00b3 [x\u2076 - x\u00b2 sin(2x)] dx</p> <p>Para esto, se implemento el m\u00e9todo mediante un script de python <code>cuadrature.py</code>, se probo varios valores de \\(N\\) con el fin de encontrar un valor para la integral con un error relativo menor a 1e-10, respecto al valor analitico.</p>"},{"location":"reference/#cuadrature.derivada_analitica","title":"<code>derivada_analitica(x)</code>","text":"<p>Calcula la antiderivada de f(x) = x\u2076 - x\u00b2 sin(2x).</p> <p>La antiderivada (se calculo manualmente) es: F(x) = x\u2077/7 + x\u00b2/2 cos(2x) - x/2 sin(2x) - 1/4 cos(2x)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or ndarray</code> <p>Variable independiente, preimagen.</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Valor de la antiderivada evaluada en x.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # F(0) = -1/4\n&gt;&gt;&gt; abs(derivada_analitica(0) - (-0.25)) &lt; 1e-10\nTrue\n&gt;&gt;&gt; # Verificar que F'(x) = f(x) aproximadamente, usando la definici\u00f3n de derivada y el calculo de un error con tolerancia de 1e-10\n&gt;&gt;&gt; x = 1.0\n&gt;&gt;&gt; h = 1e-10\n&gt;&gt;&gt; derivada_num = (derivada_analitica(x + h) - derivada_analitica(x)) / h\n&gt;&gt;&gt; derivada_exacta = func_arg_int(x)\n&gt;&gt;&gt; abs(derivada_num - derivada_exacta) &lt; 1e-10\nTrue\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def derivada_analitica(x):\n    r\"\"\"\n    Calcula la antiderivada de f(x) = x\u2076 - x\u00b2 sin(2x).\n\n    La antiderivada (se calculo manualmente) es: F(x) = x\u2077/7 + x\u00b2/2 cos(2x) - x/2 sin(2x) - 1/4 cos(2x)\n\n    Args:\n        x (float or numpy.ndarray): Variable independiente, preimagen.\n\n    Returns:\n        (float or numpy.ndarray): Valor de la antiderivada evaluada en x.\n\n    Examples:\n        &gt;&gt;&gt; # F(0) = -1/4\n        &gt;&gt;&gt; abs(derivada_analitica(0) - (-0.25)) &lt; 1e-10\n        True\n        &gt;&gt;&gt; # Verificar que F'(x) = f(x) aproximadamente, usando la definici\u00f3n de derivada y el calculo de un error con tolerancia de 1e-10\n        &gt;&gt;&gt; x = 1.0\n        &gt;&gt;&gt; h = 1e-10\n        &gt;&gt;&gt; derivada_num = (derivada_analitica(x + h) - derivada_analitica(x)) / h\n        &gt;&gt;&gt; derivada_exacta = func_arg_int(x)\n        &gt;&gt;&gt; abs(derivada_num - derivada_exacta) &lt; 1e-10\n        True\n    \"\"\"\n    return (x**7 / 7 + x**2 / 2 * np.cos(2*x) - \n            x / 2 * np.sin(2*x) - 1/4 * np.cos(2*x))\n</code></pre>"},{"location":"reference/#cuadrature.eva_int","title":"<code>eva_int(pto, peso, func)</code>","text":"<p>Eval\u00faa la integral aproximada usando cuadratura Gauss-Legendre.</p> <p>Calcula la integral usando la suma de la funci\u00f3n evaluada en los puntos de colocaci\u00f3n por los pesos respectivos.</p> <p>Parameters:</p> Name Type Description Default <code>pto</code> <code>ndarray</code> <p>Puntos de colocaci\u00f3n.</p> required <code>peso</code> <code>ndarray</code> <p>Pesos respectivos.</p> required <code>func</code> <code>callable</code> <p>Funci\u00f3n a integrar.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Valor aproximado de la integral.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pto, peso = gaussxw(2)\n&gt;&gt;&gt; pto_esc, peso_esc = gaussxwab(0, 1, pto, peso)\n&gt;&gt;&gt; # Integrar funci\u00f3n constante f(x) = 2\n&gt;&gt;&gt; result = eva_int(pto_esc, peso_esc, lambda x: 2)\n&gt;&gt;&gt; result\n2.0\n&gt;&gt;&gt; # El resultado es de la integral de 2 de 0 a 1 es 2\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def eva_int(pto, peso, func):\n    r\"\"\"\n    Eval\u00faa la integral aproximada usando cuadratura Gauss-Legendre.\n\n    Calcula la integral usando la suma de la funci\u00f3n evaluada en los puntos de colocaci\u00f3n por los pesos respectivos.\n\n    Args:\n        pto (numpy.ndarray): Puntos de colocaci\u00f3n.\n        peso (numpy.ndarray): Pesos respectivos.\n        func (callable): Funci\u00f3n a integrar.\n\n    Returns:\n        (float): Valor aproximado de la integral.\n\n    Examples:\n        &gt;&gt;&gt; pto, peso = gaussxw(2)\n        &gt;&gt;&gt; pto_esc, peso_esc = gaussxwab(0, 1, pto, peso)\n        &gt;&gt;&gt; # Integrar funci\u00f3n constante f(x) = 2\n        &gt;&gt;&gt; result = eva_int(pto_esc, peso_esc, lambda x: 2)\n        &gt;&gt;&gt; result\n        2.0\n        &gt;&gt;&gt; # El resultado es de la integral de 2 de 0 a 1 es 2\n    \"\"\"\n    return np.sum(peso * func(pto))\n</code></pre>"},{"location":"reference/#cuadrature.func_arg_int","title":"<code>func_arg_int(x)</code>","text":"<p>Funci\u00f3n que queremos integrar: f(x) = x\u2076 - x\u00b2 sin(2x).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or ndarray</code> <p>Variable independiente, preimagen.</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Valor de la funci\u00f3n evaluada en x.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; #Ejemplo con punto\n&gt;&gt;&gt; func_arg_int(0)\n0.0\n&gt;&gt;&gt; func_arg_int(1) &gt; 0\nTrue\n&gt;&gt;&gt; # Ejemplo con array\n&gt;&gt;&gt; x_vals = np.array([0, 1])\n&gt;&gt;&gt; results = func_arg_int(x_vals)\n&gt;&gt;&gt; len(results) == 2\nTrue\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def func_arg_int(x):\n    r\"\"\"\n    Funci\u00f3n que queremos integrar: f(x) = x\u2076 - x\u00b2 sin(2x).\n\n    Args:\n        x (float or numpy.ndarray): Variable independiente, preimagen.\n\n    Returns:\n        (float or numpy.ndarray): Valor de la funci\u00f3n evaluada en x.\n\n    Examples:\n        &gt;&gt;&gt; #Ejemplo con punto\n        &gt;&gt;&gt; func_arg_int(0)\n        0.0\n        &gt;&gt;&gt; func_arg_int(1) &gt; 0\n        True\n        &gt;&gt;&gt; # Ejemplo con array\n        &gt;&gt;&gt; x_vals = np.array([0, 1])\n        &gt;&gt;&gt; results = func_arg_int(x_vals)\n        &gt;&gt;&gt; len(results) == 2\n        True\n    \"\"\"\n    return x**6 - x**2 * np.sin(2 * x)\n</code></pre>"},{"location":"reference/#cuadrature.gaussxw","title":"<code>gaussxw(N)</code>","text":"<p>Calcula los nodos y pesos de la cuadratura Gauss-Legendre en el intervalo [-1, 1].</p> <p>Utiliza los polinomios de Legendre para generar los puntos de colocaci\u00f3n y sus respectivos pesos que se utilizaran para la cuadratura Gaussiana.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>N\u00famero de puntos de la cuadratura, cambiar este valor cambia el resultado de la aproximaci\u00f3n de la integral.</p> required <p>Returns:</p> Name Type Description <code>pto</code> <code>ndarray</code> <p>Array con los puntos de colocaci\u00f3n/nodos</p> <code>peso</code> <code>ndarray</code> <p>Array con los pesos correspondientes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pto, peso = gaussxw(1)  # Un solo punto\n&gt;&gt;&gt; pto[0]  # El punto est\u00e1 en el centro\n0.0\n&gt;&gt;&gt; peso[0]  # El peso es 2 (longitud del intervalo [-1,1])\n2.0\n&gt;&gt;&gt; pto, peso = gaussxw(2) # Con 2 puntos\n&gt;&gt;&gt; len(pto)\n2\n&gt;&gt;&gt; len(peso)\n2\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def gaussxw(N):\n    r\"\"\"\n    Calcula los nodos y pesos de la cuadratura Gauss-Legendre en el intervalo [-1, 1].\n\n    Utiliza los polinomios de Legendre para generar los puntos de colocaci\u00f3n\n    y sus respectivos pesos que se utilizaran para la cuadratura Gaussiana.\n\n    Args:\n        N (int): N\u00famero de puntos de la cuadratura, cambiar este valor cambia el resultado de la aproximaci\u00f3n de la integral.\n\n    Returns:\n        pto (numpy.ndarray): Array con los puntos de colocaci\u00f3n/nodos\n        peso (numpy.ndarray): Array con los pesos correspondientes\n\n    Examples:\n        &gt;&gt;&gt; pto, peso = gaussxw(1)  # Un solo punto\n        &gt;&gt;&gt; pto[0]  # El punto est\u00e1 en el centro\n        0.0\n        &gt;&gt;&gt; peso[0]  # El peso es 2 (longitud del intervalo [-1,1])\n        2.0\n        &gt;&gt;&gt; pto, peso = gaussxw(2) # Con 2 puntos\n        &gt;&gt;&gt; len(pto)\n        2\n        &gt;&gt;&gt; len(peso)\n        2\n    \"\"\"\n    pto, peso = np.polynomial.legendre.leggauss(N)\n    return pto, peso\n</code></pre>"},{"location":"reference/#cuadrature.gaussxwab","title":"<code>gaussxwab(liminf, limsup, pto, peso)</code>","text":"<p>Escala los nodos y pesos desde el intervalo [-1, 1] a [liminf, limsup].</p> <p>Transforma los puntos de colocaci\u00f3n y pesos de la cuadratura Gaussiana del intervalo est\u00e1ndar [-1, 1] a nuevos puntos de colocaci\u00f3n y pesos para cualquier intervalo [a, b].</p> <p>Parameters:</p> Name Type Description Default <code>liminf</code> <code>float</code> <p>L\u00edmite inferior del intervalo de integraci\u00f3n.</p> required <code>limsup</code> <code>float</code> <p>L\u00edmite superior del intervalo de integraci\u00f3n.</p> required <code>pto</code> <code>ndarray</code> <p>Puntos de colocaci\u00f3n en [-1, 1].</p> required <code>peso</code> <code>ndarray</code> <p>Pesos correspondientes en [-1, 1].</p> required <p>Returns:</p> Name Type Description <code>pto_esc</code> <code>ndarray</code> <p>Puntos transformados al nuevo intervalo</p> <code>peso_esc</code> <code>ndarray</code> <p>Pesos transformados al nuevo intervalo</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pto, peso = gaussxw(2)\n&gt;&gt;&gt; pto_esc, peso_esc = gaussxwab(0, 1, pto, peso)\n&gt;&gt;&gt; len(pto_esc)\n2\n&gt;&gt;&gt; # Los puntos est\u00e1n ahora en [1, 3] en lugar de [-1, 1]\n&gt;&gt;&gt; min(pto_esc) &gt;= 1\nTrue\n&gt;&gt;&gt; max(pto_esc) &lt;= 3\nTrue\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def gaussxwab(liminf, limsup, pto, peso):\n    r\"\"\"\n    Escala los nodos y pesos desde el intervalo [-1, 1] a [liminf, limsup].\n\n    Transforma los puntos de colocaci\u00f3n y pesos de la cuadratura Gaussiana\n    del intervalo est\u00e1ndar [-1, 1] a nuevos puntos de colocaci\u00f3n y pesos para cualquier intervalo [a, b].\n\n    Args:\n        liminf (float): L\u00edmite inferior del intervalo de integraci\u00f3n.\n        limsup (float): L\u00edmite superior del intervalo de integraci\u00f3n.\n        pto (numpy.ndarray): Puntos de colocaci\u00f3n en [-1, 1].\n        peso (numpy.ndarray): Pesos correspondientes en [-1, 1].\n\n    Returns:\n        pto_esc (numpy.ndarray): Puntos transformados al nuevo intervalo\n        peso_esc (numpy.ndarray): Pesos transformados al nuevo intervalo\n\n    Examples:\n        &gt;&gt;&gt; pto, peso = gaussxw(2)\n        &gt;&gt;&gt; pto_esc, peso_esc = gaussxwab(0, 1, pto, peso)\n        &gt;&gt;&gt; len(pto_esc)\n        2\n        &gt;&gt;&gt; # Los puntos est\u00e1n ahora en [1, 3] en lugar de [-1, 1]\n        &gt;&gt;&gt; min(pto_esc) &gt;= 1\n        True\n        &gt;&gt;&gt; max(pto_esc) &lt;= 3\n        True\n    \"\"\"\n    return (0.5 * (limsup - liminf) * pto + 0.5 * (limsup + liminf), \n            0.5 * (limsup - liminf) * peso)\n</code></pre>"},{"location":"reference/#cuadrature.main","title":"<code>main()</code>","text":"<p>Resuelve la integral definida \\(\\int_{1}^{3} [x^{6} - x^{2} \\sin(2x)] dx\\) utilizando la Cuadratura Gauss-Legendre y determina el n\u00famero de puntos (N) necesario para alcanzar una tolerancia de error relativo.</p> <p>El script calcula iterativamente la integral para valores crecientes de N (n\u00famero de puntos de cuadratura) hasta que el error relativo de la aproximaci\u00f3n respecto al valor anal\u00edtico es menor que una tolerancia establecida de \\(10^{-10}\\). Llegamos que con N=7, el error esta debajo de la tolerancia. </p> Outputs <ul> <li>Imprime los resultados de la convergencia en la consola.</li> <li>Genera y guarda dos gr\u00e1ficos PNG:</li> <li>'convergencia.png': Gr\u00e1fico de convergencia de la integral.</li> <li>'error.png': Gr\u00e1fico del error relativo vs N.</li> </ul> Source code in <code>cuadrature.py</code> <pre><code>def main():\n    r\"\"\"\n    Resuelve la integral definida $\\int_{1}^{3} [x^{6} - x^{2} \\sin(2x)] dx$ utilizando la Cuadratura Gauss-Legendre y determina el n\u00famero de puntos (N) necesario para alcanzar una tolerancia de error relativo.\n\n    El script calcula iterativamente la integral para valores crecientes de N\n    (n\u00famero de puntos de cuadratura) hasta que el error relativo de la\n    aproximaci\u00f3n respecto al valor anal\u00edtico es menor que una tolerancia\n    establecida de $10^{-10}$. Llegamos que con N=7, el error esta debajo de la tolerancia. \n\n    Outputs:\n        - Imprime los resultados de la convergencia en la consola.\n        - Genera y guarda dos gr\u00e1ficos PNG:\n          1. 'convergencia.png': Gr\u00e1fico de convergencia de la integral.\n          2. 'error.png': Gr\u00e1fico del error relativo vs N.\n    \"\"\"\n    print(\"Cuadratura Gaussiana: Resoluci\u00f3n de \u222b\u2081\u00b3 [x\u2076 - x\u00b2 sin(2x)] dx\")\n    # Calculo del valor anal\u00edtico/exacto\n    analytic = derivada_analitica(3) - derivada_analitica(1)\n    print(\"Valor anal\u00edtico:\", analytic)\n\n    # Se prueba con varios valores de N hasta alcanzar que el error alcanza una tolerencia de 1e-10\n    tol = 1e-10\n    N = 1\n    N_valores = []\n    integral_valores = []\n    errores = []\n\n    while True:\n        # Obtener puntos y pesos de Gauss-Legendre\n        pto, peso = gaussxw(N)\n        # Escalar al intervalo [1, 3]\n        pto_esc, peso_esc = gaussxwab(1, 3, pto, peso)\n        # Evaluar integral aproximada\n        approx = eva_int(pto_esc, peso_esc, func_arg_int)\n        # Calcular error relativo\n        err = abs(approx - analytic) / analytic\n\n        # Guardar resultados\n        N_valores.append(N)\n        integral_valores.append(approx)\n        errores.append(err)\n\n        print(f\"N = {N}, integral \u2248 {approx:.12f}, error = {err:.12f}\")\n\n        # Verificar convergencia\n        if err &lt; tol:\n            break\n        N += 1\n        # Evitar bucle infinito\n        if N &gt; 50:\n            break\n\n\n\n    print(f\"\\nPrimer N con error &lt; {tol} es N = {N}, con integral \u2248 {approx:.12f}\")\n    print(\"Notamos que este valor de N corresponde a lo que esperamos, en efecto, la teoria nos dice que este m\u00e9todo es exacto para polinomios hasta grado 2N-1. Aqui se puede aproximar el sen tal que f(x) se aproxima a un polinomio de grado 6.\")\n    # Gr\u00e1fico 1: Convergencia\n    # Se grafica la integral para varios valores de N para ver que converge al valor te\u00f3rico\n    plt.figure(figsize=(9, 6))\n    plt.plot(N_valores, integral_valores, marker='o', label=\"Aproximaci\u00f3n\")\n    plt.axhline(analytic, color=\"red\", linestyle=\"--\", label=\"Valor anal\u00edtico\")\n    plt.xlabel(\"N (n\u00famero de puntos)\")\n    plt.ylabel(\"Valor de la integral\")\n    plt.title(\"Convergencia de la cuadratura Gauss-Legendre\")\n    plt.legend()\n    plt.grid(True, ls=\"--\", alpha=0.6)\n    plt.savefig(\"convergencia.png\", dpi=300)\n    print(\"Gr\u00e1fico guardado: convergencia.png\")\n\n\n    # Gr\u00e1fico 2: Error relativo\n    # Se grafica el error para diferentes valores de N para ver que de crece\n    plt.figure(figsize=(9, 6))\n    plt.semilogy(N_valores, errores, marker='o', label=\"Error relativo\")\n    plt.xlabel(\"N (n\u00famero de puntos)\")\n    plt.ylabel(\"Error relativo\")\n    plt.title(\"Disminuci\u00f3n del error con Gauss-Legendre\")\n    plt.grid(True, which=\"both\", ls=\"--\", alpha=0.6)\n    plt.legend()\n    plt.savefig(\"error.png\", dpi=300)\n    print(\"Gr\u00e1fico guardado: error.png\")\n</code></pre>"},{"location":"tutorials/","title":"Tutorial - Ejemplo de Uso","text":""},{"location":"tutorials/#ejecutar-el-script-desde-el-terminal","title":"Ejecutar el script desde el terminal","text":"<pre><code>python cuadrature.py\n</code></pre> <p>Esto resuelve autom\u00e1ticamente la integral y genera los gr\u00e1ficos.</p>"},{"location":"tutorials/#graficos-generados","title":"Gr\u00e1ficos generados","text":"<p>Al ejecutar el script, se generan dos gr\u00e1ficos, los cuales evidencian que la cuadratura converge al valor real y que el error disminuye cuando el valor de N aumenta:</p> <p></p> <p></p>"},{"location":"tutorials/#usar-las-funciones","title":"Usar las funciones","text":"<pre><code>import cuadrature as cq\n\n# Calcular integral con 5 puntos\npto, peso = cq.gaussxw(5)\npto_esc, peso_esc = cq.gaussxwab(1, 3, pto, peso)\nresultado = cq.eva_int(pto_esc, peso_esc, cq.func_arg_int)\n\nprint(f\"Integral: {resultado}\")\n\n# Comparar con valor exacto\nexacto = cq.derivada_analitica(3) - cq.derivada_analitica(1)\nerror = abs(resultado - exacto) / exacto\n\nprint(f\"Valor exacto: {exacto}\")\nprint(f\"Error: {error:.2e}\")\n</code></pre>"},{"location":"tutorials/#resultado-esperado","title":"Resultado esperado","text":"<pre><code>Integral: 317.34422672196945\nValor exacto: 317.34424667382643\nError: 6.29e-08\n</code></pre>"}]}